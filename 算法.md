# 算法

## 1 基础思想

### 1.1 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）

散列表、栈、队列、堆、树、图都可以用这俩种方式实现，且各有特点：

1. ==数组==由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
2. ==链表==因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

### 1.2 数据结构的基本操作,具体是递归和迭代

数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。不同数据有自己定式套路，不管增删查改，这些代码都是永远无法脱离的结构。

1. 数组遍历

```cpp
void traverse(vector<int>& arr) {
    for (int i = 0; i < arr.size(); i++) {
        // 迭代访问 arr[i]
    }
}
```

2. 链表遍历框架，兼具迭代和递归结构

```cpp
class ListNode {
    public:
        int val;
        ListNode* next;
};

void traverse(ListNode* head) {
    for (ListNode* p = head; p != nullptr; p = p->next) {
        // 迭代访问 p->val
    }
}

void traverse(ListNode* head) {
    // 递归访问 head->val
    traverse(head->next);
}

```

3. 二叉树遍历框架，典型的非线性递归遍历结构

```cpp
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
};

void traverse(TreeNode* root) {
    //前序
    traverse(root->left);
    //中序
    traverse(root->right);
    //后序
}
```

4. n 叉树遍历框架

```cpp
/* 基本的 N 叉树节点 */
class TreeNode {
public:
    int val;
    vector<TreeNode*> children;
};

void traverse(TreeNode* root) {
    for (TreeNode* child : root->children)
        traverse(child);
}
```

## 2 数组/链表

顺序存储和链式存储，主要算法技巧是双指针、前缀和、差分数组

### 2.1 前缀和数组

#### 2.1.1 [leetcode303.区域和检索-数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

常规解题方法：

```cs
public class NumArray {

    private int[] _nums;

    public NumArray(int[] nums) {
        _nums = nums;
    }

    public int SumRange(int left, int right) {
        int sum = 0;
        left = Math.Max(0,left);
        right = Math.Min(right,_nums.Length-1);
        for(int i=left;i<=right;i++){
            sum += _nums[i];
        }
        return sum;
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.SumRange(left,right);
 */
```

因为 sumRange ⽅法会被频繁调⽤，⽽它的时间复杂度是 O(N)，其
中 N 代表 nums 数组的⻓度。使⽤前缀和技巧，将 sumRange 函数的时间复杂度降为 O(1)。

==使用前缀和方法==

```cs
public class NumArray {

    private int[] _preNums;

    public NumArray(int[] nums) {
        _preNums = new int[nums.Length+1];
    	for(int i=1;i<_preNums.Length;i++){
            _preNums[i]=_preNums[i-1]+nums[i-1];
    	}
    }

    public int SumRange(int left, int right) {
        return _preNums[right+1]-_preNums[left];
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.SumRange(left,right);
 */
```

sumRange 函数仅仅需要做⼀次减法运算，避免了每次进⾏ for 循环调⽤，最坏时间复杂度为常数 O(1)。

#### 2.1.2 [leetcode304.区域和检索-矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

==使用前缀和方法==

```cs
public class NumMatrix {
    private int[,] _preMatrix;
    public NumMatrix(int[][] matrix) {
        if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0) {
            throw new ArgumentException("Input matrix is null or empty.");
        }
        int m = matrix.Length, n = matrix[0].Length;
        _preMatrix = new int[m + 1, n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                _preMatrix[i, j] = _preMatrix[i - 1, j] + _preMatrix[i, j - 1] - _preMatrix[i - 1, j - 1] + matrix[i - 1][j - 1];
            }
        }
    }
    public int SumRegion(int row1, int col1, int row2, int col2) {
        return _preMatrix[row2+1, col2+1] - _preMatrix[row1 , col2+1] - _preMatrix[row2+1, col1 ] + _preMatrix[row1 , col1 ];
    }
}
/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.SumRegion(row1,col1,row2,col2);
 */
```

#### 2.1.3 [leetcode560.和为 k 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

使用前缀和后嵌套遍历

```cs
public class Solution {
  public int SubarraySum(int[] nums, int k) {
    int n = nums.Length;
    // 构造前缀和
    int[] preSum = new int[n + 1];
    preSum[0] = 0;
    for (int i = 0; i < n; i++){
      preSum[i + 1] = preSum[i] + nums[i];
    }
    int res = 0;
    // 穷举所有⼦数组
    for (int i = 1; i <= n; i++){
      for (int j = 0; j < i; j++){
        // ⼦数组 nums[j..i-1] 的元素和
        if (preSum[i] - preSum[j] == k)res++;
      }
    }
    return res;
  }
}
```

使用哈希表（数学优化）
利用==preSum[i] - preSum[j] = k==的关系判断==sum-k==是否在之前的哈希出现过

```cs
public class Solution {
  public int SubarraySum(int[] nums, int k) {
    int len = nums.Length;
    Dictionary<int, int> myDict = new Dictionary<int, int>();
    myDict.Add(0, 1);
    int res = 0 ;
    int sum = 0;
    for(int i=0;i<len;i++){
        sum = sum + nums[i];
        if(myDict.ContainsKey(sum-k)){
            res += myDict[sum-k];
        };
        if(myDict.ContainsKey(sum)){
            myDict[sum] = myDict[sum] +1;
        }else{
            myDict.Add(sum,1);
        }
    }
    return res;
  }
}
```

### 2.2 差分数组

差分数组的主要适⽤场景是==频繁==对原始数组的
某个区间的元素进⾏增减

#### 2.2.1 [leetcode1109.航班预定统计](https://leetcode.cn/problems/corporate-flight-bookings/)

```cs
public class Solution {
    public int[] CorpFlightBookings(int[][] bookings, int n) {
        int[] diff = new int[n];
        Array.Fill(diff, 0);
        foreach (int[] booking in bookings) {
            diff[booking[0] - 1] += booking[2];
            if (booking[1] < n) {
                diff[booking[1]] -= booking[2];
            }
        }
        for (int i = 1; i < n; i++) {
            diff[i] += diff[i - 1];
        }
        return diff;
    }
}
```

### 2.3 滑动窗口

==滑动窗口公式==

```cs
/* 滑动窗⼝算法框架 */
public class Solution {
  public FindAnagrams(string w, string n) {
    Dictionary<char, int> need = new Dictionary<char, int>();
    Dictionary<char, int> window = new Dictionary<char, int>();
    foreach (char c in n)
    {
        // 如果字典中没有这个键，则自动添加键并设置其值为1，否则增加现有的值
        need[c] = need.ContainsKey(c) ? need[c] + 1 : 1;
    }
    int left = 0;
    int right = 0;
    int valid = 0;

    while(right<w.Length){
      char c = w[right];
      right++;

          // 判断左侧窗⼝是否要收缩
      while (window needs shrink) {
        // d 是将移出窗⼝的字符
        char d = w[left];
        // 左移窗⼝
        left++;
        // 进⾏窗⼝内数据的⼀系列更新
        ...
      }
    }
  }
}


```

==其中两处 ... 表示的更新窗⼝数据的地⽅，到时候你直接往⾥⾯填就⾏了。
⽽且，这两个 ... 处的操作分别是右移和左移窗⼝更新操作，等会你会发现它们操作是完全对称的。==

#### 2.3.1 [leetcode76.最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

基础解题思路：
1、我们在字符串 S 中使⽤双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间[left, right) 称为⼀个「窗⼝」。
2、我们先不断地==增加 right 指针==扩⼤窗⼝ [left, right)，直到窗⼝中的字符串==符合要求==（包含了 T 中的所有字符）。
3、此时，我们==停⽌增加 right==，转⽽不断==增加 left 指针==缩⼩窗⼝ [left, right)，直到窗⼝中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新⼀轮结果。
4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

```cs
public class Solution {
    public string MinWindow(string s, string t) {
        Dictionary<char, int> need = new Dictionary<char, int>();
        Dictionary<char, int> window = new Dictionary<char, int>();
        foreach (char c in t)
        {
            // 如果字典中没有这个键，则自动添加键并设置其值为1，否则增加现有的值
            need[c] = need.ContainsKey(c) ? need[c] + 1 : 1;
        }
        int left = 0;
        int right = 0;
        int valid = 0;

        int start = 0;
        int len = int.MaxValue;

        while(right<s.Length){
            char c = s[right];
            right++;

            bool keyExists = need.ContainsKey(c);
            if (keyExists)
            {
                window[c] = window.ContainsKey(c) ? window[c] + 1 : 1;
                if(window[c]==need[c]){
                    valid++;
                }
            }
            // Console.WriteLine("left:"+left+" right:"+right);
            while (valid == need.Count) {
              if(right-left<len){
                  start = left;
                  len = right-left;
                  // Console.WriteLine("start:"+start+" len:"+len);
              }
              // d 是将移出窗⼝的字符
              char d = s[left];
              // 左移窗⼝
              left++;
              // 进⾏窗⼝内数据的⼀系列更新
              bool key= need.ContainsKey(d);
              bool key2= window.ContainsKey(d);
              if(key&&key2){
                  if(window[d]==need[d]){
                      valid--;
                  }
                  window[d]--;
              }
            }
        }
        return len == int.MaxValue?"":s.Substring(start, len);
    }
}
```

#### 2.3.2 [leetcode567.字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

```cs
public class Solution {
    public bool CheckInclusion(string s1, string s2) {
        Dictionary<char, int> need = new Dictionary<char, int>();
        Dictionary<char, int> window = new Dictionary<char, int>();
        foreach (char c in s1)
        {
            // 如果字典中没有这个键，则自动添加键并设置其值为1，否则增加现有的值
            need[c] = need.ContainsKey(c) ? need[c] + 1 : 1;
        }
        int left = 0;
        int right = 0;
        int valid = 0;

        bool res = false;
        while(right<s2.Length){
            char c = s2[right];
            right++;
            bool keyExists = need.ContainsKey(c);
            if (keyExists)
            {
                window[c] = window.ContainsKey(c) ? window[c] + 1 : 1;
                if(window[c]==need[c]){
                    valid++;
                }
            }
            while (valid == need.Count) {
              if(right-left==s1.Length){
                res = true;
                break;
              }
              // d 是将移出窗⼝的字符
              char d = s2[left];
              // 左移窗⼝
              left++;
              // 进⾏窗⼝内数据的⼀系列更新
              bool key= need.ContainsKey(d);
            //   bool key2= window.ContainsKey(d);
              if(key){
                  if(window[d]==need[d]){
                      valid--;
                  }
                  window[d]--;
              }
            }
            if(res){
                break;
            }
        }
        return res;
    }
}
```

#### 2.3.3 [leetcode438.找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```cs
public class Solution {
    public IList<int> FindAnagrams(string w, string n) {
        Dictionary<char, int> need = new Dictionary<char, int>();
        Dictionary<char, int> window = new Dictionary<char, int>();
        foreach (char c in n)
        {
            // 如果字典中没有这个键，则自动添加键并设置其值为1，否则增加现有的值
            need[c] = need.ContainsKey(c) ? need[c] + 1 : 1;
        }
        int left = 0;
        int right = 0;
        int valid = 0;

        IList<int> res = new List<int>();
        int len = n.Length;

        while(right<w.Length){
            char c = w[right];
            right++;
            if (need.ContainsKey(c))
            {
                window[c] = window.ContainsKey(c) ? window[c] + 1 : 1;
                if(window[c]==need[c]){
                    valid++;
                }
            }
                // 判断左侧窗⼝是否要收缩
            while (valid == need.Count) {
                if(right-left==len){
                    res.Add(left);
                }
                // d 是将移出窗⼝的字符
                char d = w[left];
                // 左移窗⼝
                left++;
                // 进⾏窗⼝内数据的⼀系列更新
                if(need.ContainsKey(d)){
                    if(window[d]==need[d]){
                        valid--;
                    }
                    window[d]--;
                }
            }
        }
        return res;
    }
}

```

#### 2.3.4 [leetcode3.无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

用一个 set 即可

```cs
public class Solution {
  public int LengthOfLongestSubstring(string s) {
    if(s==""){
        return 0;
    }
    HashSet<char> need = new HashSet<char>();
    int left = 0;
    int right = 0;
    int res = 1;
    while(right<s.Length){
      char c = s[right];
      right++;
      while(need.Contains(c)){
        char d = s[left];
        left++;
        if(need.Contains(d)){
          need.Remove(d);
        }
      }
      need.Add(c);
      res = Math.Max(res,need.Count);
    }
    return res;
  }
}

```

### 2.4 二分搜索

注意定义好区间是==左闭右闭==还是==左闭右开==

#### 2.4.1 [leetcode704.二分查找](https://leetcode.cn/problems/binary-search/)

```cs
public class Solution {
  public int Search(int[] nums, int target) {
    int left =0;
      int right = nums.Length-1;//左闭右闭
      while(left <=  right){
        int mid = (left+right)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]>target){
            right = mid-1;//左闭右闭
        }else if(nums[mid]<target){
            left = mid+1;//左闭右闭
        }
      }
      return -1;
  }
}
```

#### 2.4.2 [leetcode34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```cs
public class Solution {
  public int[] SearchRange(int[] nums, int target) {
    int resMix = -1;
    int resMax = -1;

    //查找左边界
    int left = 0;
    int right = nums.Length-1;
    while(left<=right){
      int mid = (left+right)/2;
      if(nums[mid] == target){
        right = mid - 1; 
      }else if(nums[mid]<target){
        left = mid+1;
      }else{
        right = mid - 1; 
      }
    }
    if (left >= nums.Length || nums[left] != target) { 
      resMix = -1; 
    }else{
      resMix = left;
    }
    // Console.WriteLine(resMix);
    //查找右边界
    left = 0;
    right = nums.Length-1;
    while(left<=right){
      int mid = (left+right)/2;
      if(nums[mid] == target){
        left = mid+1; 
      }else if(nums[mid]<target){
        left = mid+1;
      }else{
        right = mid - 1; 
      }
    }
    if (right<0 || nums[right] != target) { 
      resMax = -1; 
    }else{
      resMax = right;
    }
    // Console.WriteLine(resMax);

    return [resMix,resMax];
  } 
  
}
```
#### 2.4.3 [leetcode875.爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)
```cs
public class Solution {
  public int MinEatingSpeed(int[] piles, int h) {
    if(piles.Length==1){
      return  (int)Math.Ceiling((double)piles[0] / (double)h);
    }
    Array.Sort(piles);    
    if(piles.Length==h){
      return piles[h-1];
    }
    int left = 1;
    int right = piles[piles.Length-1];
    int res = right;
    while(left<=right){
      int mid = (left+right)/2;
      // Console.WriteLine("left:"+left+"right:"+right);
      if(calculateTime(piles,mid)>h){
        // Console.WriteLine(">");
        left = mid+1;
      }else if(calculateTime(piles,mid)<h){
        // Console.WriteLine("<");
        res = mid;
        right = mid-1;
      }else if(calculateTime(piles,mid)==h){
        // Console.WriteLine("=");
        res = mid;
        right = mid-1;
      }
    }
    return res;
  }

  public long  calculateTime (int [] piles ,int minK){
    long  resaa = 0;
    foreach (int item in piles)
    {
      long  result = (long)Math.Ceiling((double)item / (double)minK);
      resaa = resaa+ result;
    }
    return resaa;
  }
}
```
#### 2.4.4 [leetcode1011.在D天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)
```cs
public class Solution {
  public int ShipWithinDays(int[] weights, int days) {
    int left = weights.Max();
    int right = int.MaxValue;
    int res = right;

    while(left<=right){
      int mid = (int)(((long)left+(long)right)/2);
      // Console.WriteLine("left："+left+"right:"+right);
      if(getMyTime(weights,mid)>days){
        left = mid + 1;
      }else{
        res = mid;
        right = mid -1;
      }
    }
    return res;
  }

  public int getMyTime (int[] weights,int speed){
    int speedRemaining = speed;
    int res = 1;
    foreach(int weight in weights){
      if(weight<=speedRemaining){
        speedRemaining = speedRemaining - weight;
      }else{
        speedRemaining = speed-weight;
        res ++;
      }
    }
    // Console.WriteLine("负载："+speed+"day: " + res);
    return res;
  }
}
```
### 2.5 田忌赛马

#### 2.5.1 [leetcode870.优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)==后面再研究==
```cs
public class Solution {
  public int[] AdvantageCount(int[] nums1, int[] nums2) {
    
  }
}
```
### 2.6 修改数组
#### 2.6.1 [leetcode26.删除有序数组中的重复项](https://leetcode.cn/problems/advantage-shuffle/)
```cs
public class Solution {
  public int RemoveDuplicates(int[] nums) {
    int len = nums.Length;
    if(len == 0) return 0;
    int slow = 0;
    int fast = 1;
    while(fast<len){
      if(nums[fast]!=nums[slow]){
        slow = slow + 1;
        nums[slow]=nums[fast];
      }
      fast = fast+1;
    }
    return slow+1;
  }
}
```
# 分界

# 分界

# 分界

# 分界

# 分界

# 分界

# 分界

# 分界

# 分界

# 分界

#### 动态规划

1. dp 数组以及其下标的定义
2. 递推公式
3. dp 数组如何初始化
4. 遍历顺序
5. 打印 dp 数组（用于 debug）

##### 斐波那契数列：509

```
确认dp[i]的含义:dp[i]是第i个斐波那契数列
递推公式：dp[i]=dp[i-1]+dp[i-2]
初始化：dp[0]=0,dp[1]=1
遍历顺序：从前向后
打印dp数组
```

迭代

```javascript
/**
 * @param {number} n
 * @return {number}
 */

var fib = function (n) {
  if (n == 1) return 0;
  if (n == 2) return;
  let dp0 = 0;
  let dp1 = 1;
  let sum = 0;
  for (let i = 2; i < n; i++) {
    sum = dp0 + dp1;
    dp0 = dp1;
    dp1 = sum;
  }
  return sum;
};
```

递归

```javascript
/**
 * @param {number} n
 * @return {number}
 */

var fib = function (n) {
  if (n == 0) return 0;
  if (n == 1) return 1;
  return fib(n - 1) + fib(n - 2);
};
```

##### 使用最小花费爬楼梯：746

```
确认dp[i]的含义:dp[i]是爬上第i个台阶所需最小费用
递推公式：dp[i]=Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
初始化：dp[0]=0,dp[1]=0
遍历顺序：从前向后
打印dp数组
```

迭代

```javascript
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function (cost) {
  let len = cost.length;
  let dp0 = 0;
  let dp1 = 0;
  let result = 0;
  for (let i = 2; i <= len; i++) {
    result = Math.min(dp0 + cost[i - 2], dp1 + cost[i - 1]);
    dp0 = dp1;
    dp1 = result;
  }
  return result;
};
```

##### 不同路径：62

```
确认dp[i][j]的含义:dp[i][j]是到第i行第j列的不同路径个数
递推公式：dp[i][j]=dp[i-1][j]+dp[i][j-1]
初始化：dp[1][j]=1,dp[i][1]=1
遍历顺序：从前向后
打印dp数组
```

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function (m, n) {
  let result = new Array(m).fill(new Array(n).fill(0));
  for (let i = 0; i < m; i++) {
    result[i][0] = 1;
  }
  for (let j = 0; j < n; j++) {
    result[0][j] = 1;
  }
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      result[i][j] = result[i - 1][j] + result[i][j - 1];
    }
  }
  return result[m - 1][n - 1];
};
```

##### 不同的二叉搜索树：96

```
确认dp[i]的含义:dp[i]是到i个节点组成的二叉搜索树的种数
递推公式：dp[i]=dp[j]*dp[i-1-j]+dp[i](0=<j=<i)
初始化：dp[0]=1;dp[1]=1
遍历顺序：从前向后
打印dp数组
```

```js
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
  let result = new Array(n + 1).fill(0);
  result[0] = 1;
  result[1] = 1;
  for (let i = 2; i <= n; i++) {
    for (let j = 0; j <= i - 1; j++) {
      result[i] = result[j] * result[i - 1 - j] + result[i];
    }
  }
  return result[n];
};
```

#### 二分查找法

```
一定要确认好right和left的区间一般有两种：
1. [left,right]左闭右闭
2. [left,right)左闭右开
```

##### 二分查找：704

[left,right]左闭右闭

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
  let left = 0;
  let right = nums.length - 1;
  while (left <= right) {
    //左闭右闭right包含在内
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] > target) {
      right = mid - 1; //右闭mid已经不等于target应将他排除在外
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
};
```

[left,right)左闭右开

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
  let left = 0;
  let right = nums.length; //右开初始值应该大于最后一个元素的索引
  if (left == right) return 0; //左闭右开先判断是否只有元素
  while (left < right) {
    //左闭右开right不包含在内
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] > target) {
      right = mid; //mid虽然不等于target但是右开将right=mid数组内也不包括mid
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      return mid;
    }
  }
  return -1;
};
```

#### 双指针

##### 移除元素：27

```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function (nums, val) {
  let len = nums.length;
  let slowIndex = 0;
  for (let fastIndex = 0; fastIndex < len; fastIndex++) {
    if (nums[fastIndex] != val) {
      //只有快指针不等于要删除的值的时候慢指针才增加且赋值
      nums[slowIndex] = nums[fastIndex];
      slowIndex++;
    }
  }
  return slowIndex;
};
```

##### 有序数组的平方：977

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function (nums) {
  let len = nums.length;
  let result = [];

  let i = 0;
  let j = len - 1; //双指针
  while (i <= j) {
    if (nums[i] * nums[i] > nums[j] * nums[j]) {
      result.unshift(nums[i] * nums[i]);
      i++;
    } else {
      result.unshift(nums[j] * nums[j]);
      j--;
    }
  }
  return result;
};
```

##### 长度最小的子数组：209(滑动窗口思想)

```js
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  let len1 = nums.length;
  let sum = 0;
  let i = 0;

  let result = len1 + 1;
  for (let j = 0; j < len1; j++) {
    sum = sum + nums[j];
    while (sum >= target) {
      result = Math.min(result, j - i + 1);
      sum = sum - nums[i];
      i++;
    }
  }
  return result > len1 ? 0 : result;
};
```

#### 链表相关

##### 移除链表元素：203

两种方法：

1. 分为头结点和非头节点处理

   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
   /**
    * @param {ListNode} head
    * @param {number} val
    * @return {ListNode}
    */
   var removeElements = function (head, val) {
     let res = head;
     let last = res;
     if (last == null) {
       return res;
     } //为空则返回空
     while (last.next != null) {
       if (last.val == val) {
         res = res.next;
       } //头节点是否为需要删除的值
       if (last.next.val == val) {
         last.next = last.next.next;
       } else {
         last = last.next;
       } //非头结点是否为需要删除的值
     }
     if (last.val == val) {
       res = res.next;
     } //整条链表全是val时，最后一位上面循环无法判断
     return res;
   };
   ```

2. 虚拟头结点

   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
   /**
    * @param {ListNode} head
    * @param {number} val
    * @return {ListNode}
    */
   var removeElements = function (head, val) {
     let newList = new ListNode();
     newList.next = head; //在head前创造一个新的头节点的名为newList
     let last = newList;
     while (last.next != null) {
       if (last.next.val == val) {
         last.next = last.next.next;
       } else {
         last = last.next;
       }
     }
     return newList.next; //输出记得去除虚拟头节点
   };
   ```

##### 设计链表：707

```js
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

var MyLinkedList = function () {
  this.size = 0;
  this.head = new ListNode(0);
};

/**
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function (index) {
  if (index < 0 || index >= this.size) {
    return -1;
  }
  let cur = this.head;
  for (let i = 0; i <= index; i++) {
    cur = cur.next;
  }
  return cur.val;
};

/**
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function (val) {
  this.addAtIndex(0, val);
};

/**
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function (val) {
  this.addAtIndex(this.size, val);
};

/**
 * @param {number} index
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function (index, val) {
  if (index > this.size) {
    return;
  }
  index = Math.max(0, index);
  this.size++;
  let cur = this.head;
  for (let i = 0; i < index; i++) {
    cur = cur.next;
  }
  let toAdd = new ListNode(val);
  toAdd.next = cur.next;
  cur.next = toAdd;
};

/**
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function (index) {
  if (index < 0 || index >= this.size) {
    return;
  }
  this.size--;
  let cur = this.head;
  for (let i = 0; i < index; i++) {
    cur = cur.next;
  }
  cur.next = cur.next.next;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * var obj = new MyLinkedList()
 * var param_1 = obj.get(index)
 * obj.addAtHead(val)
 * obj.addAtTail(val)
 * obj.addAtIndex(index,val)
 * obj.deleteAtIndex(index)
 */
```

##### 反转链表：206

双指针直接改链表方向

注意先移 pre 防止 cur 已经改变

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  let cur = head;
  let pre = null;
  while (!!cur) {
    let temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};
```

递归思路和双指针思路一样

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  return re(null, head);
};

var re = (pre, head) => {
  if (!head) return pre;
  const temp = head.next;
  head.next = pre;
  pre = head;
  return re(pre, temp);
};
```

##### 环形链表：142

借助 Set 存储唯一值，直接在便利中检测出入口

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  const visited = new Set();
  while (head !== null) {
    if (visited.has(head)) {
      return head;
    }
    visited.add(head);
    head = head.next;
  }
  return null;
};
```

快慢指针！！！！

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  if (!head || !head.next) return null;
  let slow = head.next,
    fast = head.next.next;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (fast == slow) {
      slow = head;
      while (fast !== slow) {
        slow = slow.next;
        fast = fast.next;
      }
      return slow;
    }
  }
  return null;
};
```

#### 哈希表相关

##### 两数之和：1

常规遍历

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    for (let j = nums.length - 1; j > i; j--) {
      if (nums[i] + nums[j] == target) {
        return [i, j];
      }
    }
  }
};
```

数组方法

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */

var twoSum = function (nums, target) {
  let hash = {};
  for (let i = 0; i < nums.length; i++) {
    if (hash[target - nums[i]] !== undefined) {
      return [i, hash[target - nums[i]]];
    }
    hash[nums[i]] = i;
  }
  return [];
};
```

##### 四数之和：454

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number[]} nums3
 * @param {number[]} nums4
 * @return {number}
 */
var fourSumCount = function (nums1, nums2, nums3, nums4) {
  const abMap = new Map();
  let sum = 0;
  for (let i = 0; i < nums1.length; i++) {
    for (let j = 0; j < nums2.length; j++) {
      const count = nums1[i] + nums2[j];
      abMap.set(count, (abMap.get(count) || 0) + 1);
    }
  }
  for (let i = 0; i < nums3.length; i++) {
    for (let j = 0; j < nums4.length; j++) {
      const target = 0 - (nums3[i] + nums4[j]);
      sum += abMap.get(target) || 0;
    }
  }
  return sum;
};
```

##### **!!!!!**三数之和：15

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  let res = [];
  let len = nums.length;
  nums.sort(function (a, b) {
    return a - b;
  });
  for (let i = 0; i < len - 2; i++) {
    let left = i + 1;
    let right = len - 1;
    let a = nums[i];
    if (a > 0) return res;
    if (a == nums[i - 1]) continue;
    while (left < right) {
      let b = nums[left];
      let c = nums[right];
      let sun = a + b + c;
      if (sun < 0) {
        left++;
      } else if (sun > 0) {
        right--;
      } else {
        res.push([a, b, c]);
        while (left < right && nums[left] == nums[left + 1]) {
          left++;
        }
        while (left < right && nums[right] == nums[right - 1]) {
          right--;
        }
        left++;
        right--;
      }
    }
  }
  return res;
};
```

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        int len = nums.size();
        sort(nums.begin(), nums.end());
        for(int i=0;i<len-2;i++){
            if(nums[i]>0) {
                break;
            }
            if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重
                continue;
            }
            int j = i+1;
            int k = len-1;
            while (j<k){
                int sum = nums[i]+nums[j]+nums[k];
                if(sum==0){
                    result.push_back(vector<int>{nums[i], nums[j], nums[k]});
                    while (k > j && nums[k] == nums[k - 1]) k--;
                    while (k > j && nums[j] == nums[j + 1]) j++;
                    // 找到答案时，双指针同时收缩
                    k--;
                    j++;
                }else if(sum>0){
                    k--;
                }else if(sum<0){
                    j++;
                }
            }
        }
        return result;
    }
};
```

##### 最接近的三数之和：16

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function (nums, target) {
  let len = nums.length;
  nums.sort(function (a, b) {
    return a - b;
  });
  let res = nums[0] + nums[1] + nums[2];
  for (let i = 0; i < len - 2; i++) {
    let left = i + 1;
    let right = len - 1;
    let a = nums[i];
    // if(a>=target) return res;
    if (a == nums[i - 1]) continue;
    while (left < right) {
      let b = nums[left];
      let c = nums[right];
      let sum = a + b + c;
      let oldDif = Math.abs(res - target);
      let newDif = Math.abs(sum - target);
      if (newDif < oldDif) {
        res = sum;
      }
      if (sum < target) {
        left++;
      } else if (sum > target) {
        right--;
      } else {
        return target;
      }
    }
  }
  return res;
};
```

#### KMP 算法

常规（遇到冲突向上一个索引的值获取新的索引）

```js
const getNextArray = (arr) => {
  let j = 0;
  let next = [];
  next.push(j);
  for (let i = 1; i < arr.length; i++) {
    while (j > 0 && s[i] != s[j]) {
      j = next[j - 1];
    }
    if (s[i] == s[j]) {
      j++;
    }
    next.push(j);
  }
  return next;
};
```

数组向右移一位（用-1 做首位，遇到冲突向本索引的值获取新的索引）

```js

```

##### 重复的子字符串：459

移动匹配:

将源字符串复制一份合并，去掉到首尾元素得到新的字符串；判断新的字符串是否含有源字符串

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function (s) {
  let len = s.length;
  let a = s.concat(s).slice(1, 2 * len - 1);
  return a.includes(s);
};
```

KMP 算法

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function (s) {
  if (s.length == 0) return false;
  const getNextArray = (arr) => {
    let j = 0;
    let next = [];
    next.push(j);
    for (let i = 1; i < arr.length; i++) {
      while (j > 0 && s[i] != s[j]) {
        j = next[j - 1];
      }
      if (s[i] == s[j]) {
        j++;
      }
      next.push(j);
    }
    return next;
  };
  let tb = getNextArray(s); //使用KMP算法求出相等前后缀数组next
  return tb[tb.length - 1] != 0 &&
    s.length % (s.length - tb[tb.length - 1]) === 0
    ? true
    : false;
};
```

#### 栈

##### 删除字符串中的所有相邻重复项：1047

可运用递归（但最长实例超时）

```js
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function (s) {
  let a = s.split("");
  let deleteRepeater = (arr) => {
    let len = arr.length;
    for (let i = 1; i < len; i++) {
      if (arr[i] == arr[i - 1]) {
        arr.splice(i - 1, 2);
        arr = deleteRepeater(arr);
      }
    }
    return arr;
  };

  return deleteRepeater(a).join("");
};
```

递归超时，另起一个数组做栈来降低时间复杂度

```js
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function (s) {
  let stack = [];
  let len = s.length;
  let a = s.split("");
  for (let i = 0; i < len; i++) {
    if (stack.length == 0 || stack[0] != a[i]) {
      stack.unshift(a[i]);
    } else if (a[i] == stack[0]) {
      stack.shift();
    }
  }
  return stack.reverse().join("");
};
```

##### 逆波兰表达式求值：150

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function (tokens) {
  let sta = [];
  for (let n of tokens) {
    // console.log(n)
    if (isNaN(Number(n))) {
      let a1 = Number(sta.pop());
      let a2 = Number(sta.pop());
      if (n == "+") {
        sta.push(a1 + a2);
        // console.log(sta);
      } else if (n == "-") {
        sta.push(a2 - a1);
      } else if (n == "*") {
        sta.push(a1 * a2);
      } else if (n == "/") {
        sta.push(parseInt(a2 / a1));
      }
    } else {
      sta.push(Number(n));
    }
    console.log(sta);
  }
  return sta;
};
```

#### 二叉树

定义一个二叉树

```js
class Node {
  constructor(data, left, right) {
    this.data = data;
    this.left = left;
    this.right = right;
    this.count = 1;
  }
}
```

了解概念

1.  满二叉树
2.  完全二叉树
3.  二叉搜索树：节点左边都小于本身，右边大于本身。（对二叉树结构没要求）
4.  平衡二叉树：左子树和右子树高度差不能大于一

遍历方式

1.  深度优先搜索：前中后序遍历
2.  广度优先搜索

##### 前中后序便利

```js
前序遍历: var preorderTraversal = function (root, res = []) {
  if (!root) return res;
  res.push(root.val);
  preorderTraversal(root.left, res);
  preorderTraversal(root.right, res);
  return res;
};

中序遍历: var inorderTraversal = function (root, res = []) {
  if (!root) return res;
  inorderTraversal(root.left, res);
  res.push(root.val);
  inorderTraversal(root.right, res);
  return res;
};

后序遍历: var postorderTraversal = function (root, res = []) {
  if (!root) return res;
  postorderTraversal(root.left, res);
  postorderTraversal(root.right, res);
  res.push(root.val);
  return res;
};
```

##### 广度优先搜索

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    let queue=[];
    let res=[];
    queue.push(root);
    if(root==null){
        return res;
    }
    while(queue.length!==0){
        let len=queue.length;
        let curLevel=[];
        for(let i=0;i<len;i++){
            let node=queue.shift();
            curLevel.push(node.val);

            node.left&&queue.push(node.left);
            node.right&&queue.push(node.right);
        }
        res.push(curLevel);
    }
    return res;
```

##### 对称二叉树：101

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
  let compare = (left, right) => {
    if (left == null && right != null) return false;
    else if (right == null && left != null) return false;
    else if (right == null && left == null) return true;
    else if (right.val != left.val) return false;
    let out11 = compare(left.left, right.right);
    let in11 = compare(left.right, right.left);
    return out11 && in11;
  };
  return compare(root.left, root.right);
};
```

##### 删除二叉搜索树中的节点：450

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} key
 * @return {TreeNode}
 */
var deleteNode = function (root, key) {
  if (!root) return null;
  if (key > root.val) {
    root.right = deleteNode(root.right, key);
    return root;
  } else if (key < root.val) {
    root.left = deleteNode(root.left, key);
    return root;
  } else {
    if (!root.left && !root.right) {
      return null;
    } else if (!root.left && !!root.right) {
      return root.right;
    } else if (!!root.left && !root.right) {
      return root.left;
    } else {
      let cur = root.right;
      while (cur.left) {
        cur = cur.left;
      }
      cur.left = root.left;
      return root.right;
    }
  }
};
```

##### 把二叉搜索树转换为累加树：538

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var convertBST = function (root) {
  let adding = 0;
  let traverse = (root) => {
    if (!root) return;
    traverse(root.right);
    root.val += adding;
    adding = root.val;
    traverse(root.left);
  };
  traverse(root);
  return root;
};
```

#### 排序数组：912

##### 冒泡排序

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function (nums) {
  let len = nums.length;
  for (let j = 1; j < len; j++) {
    for (let i = 0; i < len - j; i++) {
      if (nums[i] > nums[i + 1]) {
        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];
      }
    }
  }
  return nums;
};
```

##### 快速排序

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortQuickArray = function (nums) {
  let len = nums.length;
  if (len < 2) {
    return nums;
  }
  let currrr = nums[0];
  let left = [];
  let right = [];
  for (let i = 1; i < len; i++) {
    if (nums[i] < currrr) {
      left.push(nums[i]);
    }
    if (nums[i] >= currrr) {
      right.push(nums[i]);
    }
  }
  return [...sortQuickArray(left), currrr, ...sortQuickArray(right)];
};
```

##### 选择排序

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function (nums) {
  let len = nums.length;
  for (let i = 0; i < len - 1; i++) {
    let maxIndex = i;
    for (let j = i + 1; i < len; i++) {
      if (nums[j] > nums[maxIndex]) {
        maxIndex = j;
      }
    }
    [nums[maxIndex], nums[i]] = [nums[i], nums[maxIndex]];
  }
  return nums;
};
```

##### 插入排序

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function (nums) {
  let len = nums.length;

  for (let i = 0; i < len; i++) {}

  return nums;
};
```

#### 回溯法

回溯一定跟随递归，一般在递归之后

解决常见问题：组合问题、切割问题、子集问题、排列问题、棋盘问题、

回溯理解：所有回溯可以抽象为一个树形结构。树的深度通过递归递进

##### 回溯三部曲

1.递归函数的参数和返回值

2.确定递归终止条件

3.确定递归逻辑

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

##### 组合：77

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
let result = [];
let path = [];
var combine = function (n, k) {
  result = [];
  combineHelper(n, k, 1);
  return result;
};
const combineHelper = (n, k, startIndex) => {
  if (path.length === k) {
    result.push([...path]);
    return;
  }
  for (let i = startIndex; i <= n - (k - path.length) + 1; ++i) {
    path.push(i);
    combineHelper(n, k, i + 1);
    path.pop();
  }
};
```

##### 组合总和 III：216

```js
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function (k, n) {
  let res = [];
  let path = [];
  let sum = 0;
  const backstacking = (path, startIndex) => {
    if (sum > n) return;
    if (path.length == k) {
      if (sum == n) return res.push([...path]);
      return;
    }
    //注意剪枝
    for (let i = startIndex; i <= 9 - (k - path.length) + 1; i++) {
      path.push(i);
      sum = sum + i;
      startIndex += 1;
      backstacking(path, startIndex);
      sum -= i;
      path.pop();
    }
  };

  backstacking(path, 1);
  return res;
};
```

##### 分割回文串：131

```c++
class Solution {
public:
    vector<vector<string>> result;
    vector<string> path;
    void backtracking(const string & s , int startIndex ){
        if(startIndex >= s.size()){
            result.emplace_back(path);
            return;
        }
        for(int i=startIndex;i<s.size();i++){
            if(isP(s,startIndex,i)){
                string str = s.substr(startIndex,i-startIndex+1);
                path.emplace_back(str);
                backtracking(s,i+1);
                path.pop_back();
            }
        }
    }

    bool isP(const string& s,int start,int end){
        for(int i=start,j=end;i<j;i++,j--){
            if(s[i]!=s[j]){
                return false;
            }
        }
        return true;
    }

    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        backtracking(s,0);
        return result;
    }
};
```

#### 贪心算法

将问题分解为若干个子问题
找出适合的贪心策略
求解每一个子问题的最优解
将局部最优解堆叠成全局最优解

##### 分发饼干：455

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        int result=0;
        sort(g.begin(),g.end(),greater<int>());
        sort(s.begin(),s.end(),greater<int>());
        int g_star=0;
        for(int j=0;j<s.size();j++){
            if(g_star>=g.size()){
                break;
            }
            for(int i=g_star;i<g.size();i++){
                if(s[j]>=g[i]){
                    result++;
                    g_star = i+1;
                    break;
                }
            }
        }
        return result;
    }
};

//官方使用双指针:
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int m = g.length, n = s.length;
        int count = 0;
        for (int i = 0, j = 0; i < m && j < n; i++, j++) {
            while (j < n && g[i] > s[j]) {
                j++;
            }
            if (j < n) {
                count++;
            }
        }
        return count;
    }
}
```

##### 摆动序列：376

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int res = 1;
        int oldDiff = 0;
        for(int i=0;i<nums.size()-1;i++){
            int newDiff = translateSingle(nums[i]-nums[i+1]);
            if(newDiff != oldDiff&&newDiff!=0){
                res++;
                oldDiff = newDiff;
            }
        }
        return res;
    };

    int translateSingle(int n){
        if(n>0){
            return 1;
        }else if(n==0){
            return 0;
        }else{
            return -1;
        }
    };
};
```

##### **!!!!!**最大子数组和：53

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count;
            }
            if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
        return result;
    }
};
```

##### 买卖股票的最佳时机 II：122

```c++
贪心算法

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res=0;
        for(int i=1;i<prices.size();i++){
            res += max(prices[i]-prices[i-1],0);
        }
        return res;
    }
};

后面可以用动态规划实现
```

##### 跳跃游戏 II：45

```c++
贪心算法

class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size()<=1){
            return 0;
        }
        int res=0;
        int curMax=0;
        int nextMax=0;
        for(int i=0;i<nums.size();i++){
            nextMax = max(nums[i]+i,nextMax);
            if(curMax == i){
                res++;
                curMax = nextMax;
                if (nextMax >= nums.size() - 1) break;
            }
        }
        return res;
    }
};

后面可以用动态规划实现
```
